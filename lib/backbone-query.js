// Generated by CoffeeScript 1.3.3
/*
Backbone Query - A lightweight query API for Backbone Collections
(c)2012 - Dave Tonge
May be freely distributed according to MIT license.
*/

/* UTILS
*/

var Backbone, detect, filter, getCache, getModels, getSortedModels, getType, iterator, makeObj, pageModels, parseQuery, performQuery, processQuery, reject, sortModels, testModelAttribute, testQueryValue, _,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

filter = function(array, test) {
  var val, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    val = array[_i];
    if (test(val)) {
      _results.push(val);
    }
  }
  return _results;
};

reject = function(array, test) {
  var val, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    val = array[_i];
    if (!test(val)) {
      _results.push(val);
    }
  }
  return _results;
};

detect = function(array, test) {
  var val, _i, _len;
  for (_i = 0, _len = array.length; _i < _len; _i++) {
    val = array[_i];
    if (test(val)) {
      return true;
    }
  }
  return false;
};

makeObj = function() {
  var args, current, key, o, val;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  o = {};
  current = o;
  while (args.length) {
    key = args.shift();
    val = (args.length === 1 ? args.shift() : {});
    current = current[key] = val;
  }
  return o;
};

getType = function(item) {
  if (_.isRegExp(item)) {
    return "$regex";
  }
  if (_.isDate(item)) {
    return "$date";
  }
  if (_.isObject(item) && !_.isArray(item)) {
    return "object";
  }
  if (_.isArray(item)) {
    return "array";
  }
  if (_.isString(item)) {
    return "string";
  }
  if (_.isNumber(item)) {
    return "number";
  }
  if (_.isBoolean(item)) {
    return "boolean";
  }
  if (_.isFunction(item)) {
    return "function";
  }
  return false;
};

/*
Function to parse raw queries
@param {mixed} raw query
@return {array} parsed query

Allows queries of the following forms:
query
  name: "test"
  id: $gte: 10

query [
  {name:"test"}
  {id:$gte:10}
]
*/


parseQuery = function(rawQuery) {
  var key, o, paramType, q, query, queryArray, queryParam, type, val, value, _i, _len, _results;
  if (_.isArray(rawQuery)) {
    queryArray = rawQuery;
  } else {
    queryArray = (function() {
      var _results;
      _results = [];
      for (key in rawQuery) {
        if (!__hasProp.call(rawQuery, key)) continue;
        val = rawQuery[key];
        _results.push(makeObj(key, val));
      }
      return _results;
    })();
  }
  _results = [];
  for (_i = 0, _len = queryArray.length; _i < _len; _i++) {
    query = queryArray[_i];
    for (key in query) {
      if (!__hasProp.call(query, key)) continue;
      queryParam = query[key];
      o = {
        key: key
      };
      paramType = getType(queryParam);
      switch (paramType) {
        case "$regex":
        case "$date":
          o.type = paramType;
          o.value = queryParam;
          break;
        case "object":
          if (key === "$and" || key === "$or" || key === "$nor" || key === "$not") {
            o.value = queryParam;
            o.type = key;
            o.key = null;
          } else {
            for (type in queryParam) {
              value = queryParam[type];
              if (testQueryValue(type, value)) {
                o.type = type;
                switch (type) {
                  case "$elemMatch":
                  case "$relationMatch":
                    o.value = parseQuery(value);
                    break;
                  case "$computed":
                    q = makeObj(key, value);
                    o.value = parseQuery(q);
                    break;
                  default:
                    o.value = value;
                }
              }
            }
          }
          break;
        default:
          o.type = "$equal";
          o.value = queryParam;
      }
      if ((o.type === "$equal") && (paramType === "object" || paramType === "array")) {
        o.type = "$oEqual";
      }
    }
    _results.push(o);
  }
  return _results;
};

testQueryValue = function(type, value) {
  switch (type) {
    case "$in":
    case "$nin":
    case "$all":
    case "$any":
      return _(value).isArray();
    case "$size":
      return _(value).isNumber();
    case "$regex":
      return _(value).isRegExp();
    case "$like":
    case "$likeI":
      return _(value).isString();
    case "$between":
      return _(value).isArray() && (value.length === 2);
    case "$cb":
      return _(value).isFunction();
    default:
      return true;
  }
};

testModelAttribute = function(type, value) {
  switch (type) {
    case "$like":
    case "$likeI":
    case "$regex":
      return _(value).isString();
    case "$contains":
    case "$all":
    case "$any":
    case "$elemMatch":
      return _(value).isArray();
    case "$size":
      return _(value).isArray() || _(value).isString();
    case "$in":
    case "$nin":
      return value != null;
    case "$relationMatch":
      return (value != null) && value.models;
    default:
      return true;
  }
};

performQuery = function(type, value, attr, model, key) {
  switch (type) {
    case "$equal":
      if (_(attr).isArray()) {
        return __indexOf.call(attr, value) >= 0;
      } else {
        return attr === value;
      }
      break;
    case "$oEqual":
      return _(attr).isEqual(value);
    case "$contains":
      return __indexOf.call(attr, value) >= 0;
    case "$ne":
      return attr !== value;
    case "$lt":
      return attr < value;
    case "$gt":
      return attr > value;
    case "$lte":
      return attr <= value;
    case "$gte":
      return attr >= value;
    case "$between":
      return (value[0] < attr && attr < value[1]);
    case "$in":
      return __indexOf.call(value, attr) >= 0;
    case "$nin":
      return __indexOf.call(value, attr) < 0;
    case "$all":
      return _(value).all(function(item) {
        return __indexOf.call(attr, item) >= 0;
      });
    case "$any":
      return _(attr).any(function(item) {
        return __indexOf.call(value, item) >= 0;
      });
    case "$size":
      return attr.length === value;
    case "$exists":
    case "$has":
      return (attr != null) === value;
    case "$like":
      return attr.indexOf(value) !== -1;
    case "$likeI":
      return attr.toLowerCase().indexOf(value.toLowerCase()) !== -1;
    case "$regex":
      return value.test(attr);
    case "$cb":
      return value.call(model, attr);
    case "$elemMatch":
      return iterator(attr, value, false, detect, "elemMatch");
    case "$relationMatch":
      return iterator(attr.models, value, false, detect, "relationMatch");
    case "$computed":
      return iterator([model], value, false, detect, "computed");
    case "$and":
    case "$or":
    case "$nor":
    case "$not":
      return (processQuery[type]([model], value)).length === 1;
    default:
      return false;
  }
};

iterator = function(models, query, andOr, filterFunction, subQuery) {
  var parsedQuery;
  if (subQuery == null) {
    subQuery = false;
  }
  parsedQuery = subQuery ? query : parseQuery(query);
  return filterFunction(models, function(model) {
    var attr, q, test, _i, _len;
    for (_i = 0, _len = parsedQuery.length; _i < _len; _i++) {
      q = parsedQuery[_i];
      attr = (function() {
        switch (subQuery) {
          case "elemMatch":
            return model[q.key];
          case "computed":
            return model[q.key]();
          default:
            return model.get(q.key);
        }
      })();
      test = testModelAttribute(q.type, attr);
      if (test) {
        test = performQuery(q.type, q.value, attr, model, q.key);
      }
      if (andOr === test) {
        return andOr;
      }
    }
    return !andOr;
  });
};

processQuery = {
  $and: function(models, query) {
    return iterator(models, query, false, filter);
  },
  $or: function(models, query) {
    return iterator(models, query, true, filter);
  },
  $nor: function(models, query) {
    return iterator(models, query, true, reject);
  },
  $not: function(models, query) {
    return iterator(models, query, false, reject);
  }
};

getCache = function(collection, query, options) {
  var cache, models, queryString, _ref;
  queryString = JSON.stringify(query);
  cache = (_ref = collection._queryCache) != null ? _ref : collection._queryCache = {};
  models = cache[queryString];
  if (!models) {
    models = getSortedModels(collection, query, options);
    cache[queryString] = models;
  }
  return models;
};

getModels = function(collection, query) {
  var compoundKeys, compoundQuery, key, queryKeys, reduceIterator, val;
  queryKeys = _(query).keys();
  compoundKeys = ["$and", "$not", "$or", "$nor"];
  compoundQuery = _.intersection(compoundKeys, queryKeys);
  if (compoundQuery.length === 0) {
    return processQuery.$and(collection.models, query);
  } else {
    if (compoundQuery.length !== queryKeys.length) {
      if (__indexOf.call(compoundQuery, "$and") < 0) {
        query.$and = {};
        compoundQuery.unshift("$and");
      }
      for (key in query) {
        if (!__hasProp.call(query, key)) continue;
        val = query[key];
        if (!(__indexOf.call(compoundKeys, key) < 0)) {
          continue;
        }
        query.$and[key] = val;
        delete query[key];
      }
    }
    reduceIterator = function(memo, queryType) {
      return processQuery[queryType](memo, query[queryType]);
    };
    return _.reduce(compoundQuery, reduceIterator, collection.models);
  }
};

getSortedModels = function(collection, query, options) {
  var models;
  models = getModels(collection, query);
  if (options.sortBy) {
    models = sortModels(models, options);
  }
  return models;
};

sortModels = function(models, options) {
  if (_(options.sortBy).isString()) {
    models = _(models).sortBy(function(model) {
      return model.get(options.sortBy);
    });
  } else if (_(options.sortBy).isFunction()) {
    models = _(models).sortBy(options.sortBy);
  }
  if (options.order === "desc") {
    models = models.reverse();
  }
  return models;
};

pageModels = function(models, options) {
  var end, sliced_models, start, total_pages;
  if (options.offset) {
    start = options.offset;
  } else if (options.page) {
    start = (options.page - 1) * options.limit;
  } else {
    start = 0;
  }
  end = start + options.limit;
  sliced_models = models.slice(start, end);
  if (options.pager && _.isFunction(options.pager)) {
    total_pages = Math.ceil(models.length / options.limit);
    options.pager(total_pages, sliced_models);
  }
  return sliced_models;
};

if (typeof require !== 'undefined') {
  _ = require('underscore');
  Backbone = require('backbone');
}

Backbone.QueryCollection = Backbone.Collection.extend({
  query: function(query, options) {
    var models;
    if (options == null) {
      options = {};
    }
    if (options.cache) {
      models = getCache(this, query, options);
    } else {
      models = getSortedModels(this, query, options);
    }
    if (options.limit) {
      models = pageModels(models, options);
    }
    return models;
  },
  findOne: function(query) {
    return this.query(query)[0];
  },
  whereBy: function(params, options) {
    if (options == null) {
      options = {};
    }
    return new this.constructor(this.query(params, options));
  },
  resetQueryCache: function() {
    return this._queryCache = {};
  }
});

if (typeof exports !== "undefined") {
  exports.QueryCollection = Backbone.QueryCollection;
}
